<!-- Generated by SpecStory -->

# Adaptar pantalla para coherencia de dise√±o (2025-09-24 12:37Z)

_**User (2025-09-24 09:29Z)**_

/plan-feature 

Teniendo en cuenta el redise√±o que hemos hecho por ejemplo en @0006_PLAN.md , @0005_PLAN.md o @0004_PLAN.md basado en @neon-cyber-design.html , queda la pantalla de @ending-scene.js . ¬øPuedes adaptarla para que tenga coherencia con @welcome-scene.js o @players-scene.js ?

--- Cursor Command: plan-feature.md ---
El usuario proporcionar√° una descripci√≥n de una funcionalidad. Tu trabajo es:

1. Crear un plan t√©cnico que describa de forma concisa la funcionalidad que el usuario quiere construir.
2. Investigar los archivos y funciones que deben cambiarse para implementar la funcionalidad
3. Evitar cualquier secci√≥n al estilo de product manager (sin criterios de √©xito, cronograma, migraci√≥n, etc)
4. Evitar escribir cualquier c√≥digo real en el plan.
5. Incluir detalles espec√≠ficos y textuales del prompt del usuario para garantizar que el plan sea preciso.

Esto es estrictamente un documento de requisitos t√©cnicos que debe:

1. Incluir una breve descripci√≥n para establecer el contexto al principio
2. Se√±alar todos los archivos y funciones relevantes que deban cambiarse o crearse
3. Explicar cualquier algoritmo que se utilice paso a paso
4. Si es necesario, dividir el trabajo en fases l√≥gicas. Idealmente, esto deber√≠a hacerse de manera que tenga una fase inicial de ‚Äúcapa de datos‚Äù que defina los tipos y los cambios de base de datos que deben ejecutarse, seguida de N fases que puedan hacerse en paralelo (p. ej., Fase 2A - UI, Fase 2B - API). Solo incluye fases si es una funcionalidad REALMENTE grande.

Si los requisitos del usuario no est√°n claros, especialmente despu√©s de investigar los archivos relevantes, puedes hacer hasta 5 preguntas de clarificaci√≥n antes de escribir el plan. Si lo haces, incorpora las respuestas del usuario en el plan.

Prioriza ser conciso y preciso. Haz el plan lo m√°s ajustado posible sin perder ninguno de los detalles cr√≠ticos de los requisitos del usuario.

Escribe el plan en un archivo docs/features/<N>_PLAN.md con el siguiente n√∫mero de funcionalidad disponible (empezando por 0001)
--- End Command ---

---

_**Assistant**_

Voy a investigar el estado actual de `ending-scene.js` y compararlo con el dise√±o neon/cyber implementado en las otras escenas para crear un plan coherente.


---

Read file: undefined

---

Read file: undefined

---

Read file: undefined

---

Ahora voy a verificar qu√© archivos de plan ya existen para determinar el siguiente n√∫mero:


---

<details>
            <summary>Listed directory undefined ‚Ä¢ **0** results</summary>
        
No results found
</details>

---

Perfecto, ahora voy a crear el plan para el redise√±o neon/cyber de la escena de finalizaci√≥n:


---



---

He creado el plan t√©cnico para el redise√±o neon/cyber de la pantalla de finalizaci√≥n (`EndingScene`). El plan est√° dise√±ado para mantener coherencia visual completa con las escenas de bienvenida y jugadores ya redise√±adas.

**Puntos clave del plan:**

1. **Reutilizaci√≥n de c√≥digo probado**: Utiliza las mismas implementaciones de fondo cyberpunk que ya funcionan en `welcome-scene.js` y `players-scene.js`

2. **Conversi√≥n a DOM elements**: Cambia de `this.make.text()` a elementos DOM con HTML/CSS para obtener el control total sobre los estilos neon

3. **Paleta coherente**: Usa los mismos colores (cian, magenta, verde, amarillo) y efectos glow que las otras escenas

4. **Funcionalidad intacta**: Preserva toda la l√≥gica de finalizaci√≥n de partida, solo cambia la presentaci√≥n visual

5. **Animaciones mejoradas**: Implementa transiciones m√°s elaboradas y efectos de entrada escalonados

El plan est√° estructurado para ser implementado de forma incremental, reutilizando c√≥digo existente y manteniendo la coherencia visual en todo el juego.

---

_**User (2025-09-24 09:29Z)**_

implementa!

---

_**Assistant**_

¬°Perfecto! Voy a implementar el redise√±o neon/cyber de la pantalla de finalizaci√≥n siguiendo el plan que acabamos de crear.


---

## Todo List

- [-] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
- [ ] Convertir texto del ganador a DOM element con estilos neon
- [ ] Convertir resumen de resultados a lista estilizada con tarjetas
- [ ] Reemplazar botones con elementos DOM cyberpunk
- [ ] Implementar animaciones de entrada mejoradas

---

<details><summary>Edit file: src/phaser-ui/scenes/ending-scene.js</summary>

undefined

**Chunk 1**
Lines added: 206, lines removed: 7

```diff
@@ -19,11 +19,210 @@
      const w = this.cameras.main.width;
      const h = this.cameras.main.height;
-     this.addWinner(w, h);
-     this.addSummary(w, h);
-     if (this.game.numGame < ENDING_GAME_NUMBER) {
-       this.addRestartButton(w, h);
-     } else {
-       this.addEndButton(w, h);
-     }
+     
+     // Crear fondo cyberpunk
+     this.createCyberBackground();
+     
+     // A√±adir elementos con animaciones escalonadas
+     this.time.delayedCall(200, () => this.addWinner(w, h));
+     this.time.delayedCall(400, () => this.addSummary(w, h));
+     this.time.delayedCall(800, () => {
+       if (this.game.numGame < ENDING_GAME_NUMBER) {
+         this.addRestartButton(w, h);
+       } else {
+         this.addEndButton(w, h);
+       }
+     });
+   }
+ 
+   createCyberBackground() {
+     const w = this.cameras.main.width;
+     const h = this.cameras.main.height;
+ 
+     // Create base background with simulated gradient
+     this.createGradientBackground(w, h);
+ 
+     // Add radial gradient spots for neon effect
+     this.createRadialGlows(w, h);
+ 
+     // Create animated grid
+     this.createAnimatedGrid(w, h);
+ 
+     // Create floating particles
+     this.createFloatingParticles(w, h);
+   }
+ 
+   createGradientBackground(w, h) {
+     // Create a simpler gradient background using fillGradientStyle
+     const backgroundGraphics = this.add.graphics();
+     
+     // Use Phaser's built-in gradient support
+     backgroundGraphics.fillGradientStyle(0x0f0f23, 0x0f0f23, 0x16213e, 0x1a1a2e, 1);
+     backgroundGraphics.fillRect(0, 0, w, h);
+ 
+     // Add a second layer for more depth
+     const overlayGraphics = this.add.graphics();
+     overlayGraphics.fillGradientStyle(0x1a1a2e, 0x16213e, 0x0f0f23, 0x1a1a2e, 0.7);
+     overlayGraphics.fillRect(0, 0, w, h);
+     overlayGraphics.setBlendMode(Phaser.BlendModes.OVERLAY);
+   }
+ 
+   createRadialGlows(w, h) {
+     // Cyan triangle glow at 20% 50%
+     this.drawTriangleGlow(w * 0.2, h * 0.5, w * 0.2, 0, 0x00f5ff);
+ 
+     // Magenta triangle glow at 80% 20% (rotated)
+     this.drawTriangleGlow(w * 0.8, h * 0.2, w * 0.15, Math.PI / 3, 0xff0080);
+ 
+     // Green triangle glow at 40% 80% (different rotation)
+     this.drawTriangleGlow(w * 0.4, h * 0.8, w * 0.18, -Math.PI / 4, 0x39ff14);
+   }
+ 
+   drawTriangleGlow(centerX, centerY, size, rotation, color) {
+     // Create multiple triangle layers for glow effect
+     const numLayers = 6;
+     
+     for (let i = 0; i < numLayers; i++) {
+       const graphics = this.add.graphics();
+       const layerSize = size * (1 + i * 0.4);
+       const layerAlpha = 0.3 - (i * 0.04); // Start with higher alpha
+       
+       graphics.fillStyle(color, layerAlpha);
+       graphics.setBlendMode(Phaser.BlendModes.ADD);
+       
+       // Calculate triangle points
+       const angle1 = rotation;
+       const angle2 = rotation + (2 * Math.PI / 3);
+       const angle3 = rotation + (4 * Math.PI / 3);
+       
+       const x1 = centerX + Math.cos(angle1) * layerSize;
+       const y1 = centerY + Math.sin(angle1) * layerSize;
+       const x2 = centerX + Math.cos(angle2) * layerSize;
+       const y2 = centerY + Math.sin(angle2) * layerSize;
+       const x3 = centerX + Math.cos(angle3) * layerSize;
+       const y3 = centerY + Math.sin(angle3) * layerSize;
+       
+       // Draw triangle
+       graphics.beginPath();
+       graphics.moveTo(x1, y1);
+       graphics.lineTo(x2, y2);
+       graphics.lineTo(x3, y3);
+       graphics.closePath();
+       graphics.fillPath();
+     }
+   }
+ 
+   createAnimatedGrid(w, h) {
+     const gridSize = 50;
+     const gridGraphics = this.add.graphics();
+     gridGraphics.lineStyle(1, 0x00f5ff, 0.1);
+ 
+     // Create vertical lines
+     for (let x = 0; x <= w + gridSize; x += gridSize) {
+       gridGraphics.moveTo(x, 0);
+       gridGraphics.lineTo(x, h + gridSize);
+     }
+ 
+     // Create horizontal lines
+     for (let y = 0; y <= h + gridSize; y += gridSize) {
+       gridGraphics.moveTo(0, y);
+       gridGraphics.lineTo(w + gridSize, y);
+     }
+ 
+     gridGraphics.strokePath();
+ 
+     // Animate the grid
+     this.tweens.add({
+       targets: gridGraphics,
+       x: -gridSize,
+       y: -gridSize,
+       duration: 20000,
+       repeat: -1,
+       ease: 'Linear'
+     });
+   }
+ 
+   createFloatingParticles(w, h) {
+     const colors = [0x00f5ff, 0xff0080, 0x39ff14, 0xffff00];
+     const particles = [];
+ 
+     // Create 12 triangle particles
+     for (let i = 0; i < 12; i++) {
+       const particle = this.add.graphics();
+       const color = colors[i % colors.length];
+       const size = Phaser.Math.Between(2, 4);
+       
+       particle.fillStyle(color, 0.8);
+       
+       // Draw small triangle
+       particle.beginPath();
+       particle.moveTo(0, -size);
+       particle.lineTo(-size, size);
+       particle.lineTo(size, size);
+       particle.closePath();
+       particle.fillPath();
+       
+       // Random starting position
+       particle.x = Phaser.Math.Between(0, w);
+       particle.y = h + 50;
+       
+       particles.push(particle);
+ 
+       // Animate particle floating up
+       const delay = Phaser.Math.Between(0, 6000);
+       const duration = Phaser.Math.Between(4000, 8000);
+ 
+       this.time.delayedCall(delay, () => {
+         this.animateParticle(particle, w, h, duration);
+       });
+     }
+ 
+     this.particles = particles;
+   }
+ 
+   animateParticle(particle, w, h, duration) {
+     // Reset particle position
+     particle.x = Phaser.Math.Between(0, w);
+     particle.y = h + 50;
+     particle.alpha = 0;
+ 
+     // Create floating animation
+     this.tweens.add({
+       targets: particle,
+       y: -50,
+       alpha: 1,
+       duration: duration,
+       ease: 'Sine.easeInOut',
+       onComplete: () => {
+         // Restart animation
+         const newDuration = Phaser.Math.Between(4000, 8000);
+         this.animateParticle(particle, w, h, newDuration);
+       }
+     });
+ 
+     // Add rotation
+     this.tweens.add({
+       targets: particle,
+       rotation: Math.PI * 2,
+       duration: duration,
+       ease: 'Linear'
+     });
+ 
+     // Add fade out at the end
+     this.tweens.add({
+       targets: particle,
+       alpha: 0,
+       duration: 1000,
+       delay: duration - 1000,
+       ease: 'Sine.easeIn'
+     });
+ 
+     // Add fade in at the beginning
+     this.tweens.add({
+       targets: particle,
+       alpha: 1,
+       duration: 1000,
+       delay: 500,
+       ease: 'Sine.easeOut'
+     });
    }
  
```

</details>

---

## Todo List

- [x] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
- [-] Convertir texto del ganador a DOM element con estilos neon
- [ ] Convertir resumen de resultados a lista estilizada con tarjetas
- [ ] Reemplazar botones con elementos DOM cyberpunk
- [ ] Implementar animaciones de entrada mejoradas

---

Ahora voy a convertir el texto del ganador a un elemento DOM con estilos cyberpunk:


---

<details><summary>Edit file: src/phaser-ui/scenes/ending-scene.js</summary>

undefined

**Chunk 1**
Lines added: 100, lines removed: 15

```diff
@@ -255,21 +255,106 @@
  
    addWinner (w, h) {
-     const winnerText = this.make.text({
-       x: w / 2,
-       y: h / 3,
-       text: `${this.i18n.get('winner')}: ${this.game.winner}\n${this.game.winnerSecs} segs.`,
-       style: {
-         font: '4vw monospace',
-         fill: '#000000',
-         align: 'center',
-       },
-     }).setOrigin(0.5, 0.5)
-       .setScale(0);
- 
+     // Create cyberpunk winner text using DOM element
+     const winnerHtml = `
+         <style>
+         @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
+         
+         .cyber-winner {
+             font-family: 'Orbitron', 'Courier New', monospace;
+             font-size: 6vw;
+             font-weight: 900;
+             color: #ffff00;
+             text-align: center;
+             text-transform: uppercase;
+             letter-spacing: 3px;
+             line-height: 1.2;
+             text-shadow: 
+                 0 0 5px #000,
+                 0 0 10px #000,
+                 0 0 15px #000,
+                 0 0 20px #000,
+                 0 0 10px #ffff00,
+                 0 0 20px #ffff00,
+                 0 0 30px #ffff00,
+                 0 0 40px #ffff00;
+             animation: winnerGlow 2s ease-in-out infinite alternate;
+             background: rgba(0, 0, 0, 0.8);
+             padding: 3vh;
+             border-radius: 12px;
+             border: 2px solid #ffff00;
+             box-shadow: 
+                 0 0 30px rgba(255, 255, 0, 0.3),
+                 inset 0 0 20px rgba(0, 0, 0, 0.7);
+         }
+         
+         @keyframes winnerGlow {
+             0% { 
+                 text-shadow: 
+                     0 0 5px #000,
+                     0 0 10px #000,
+                     0 0 15px #000,
+                     0 0 20px #000,
+                     0 0 10px #ffff00,
+                     0 0 20px #ffff00,
+                     0 0 30px #ffff00,
+                     0 0 40px #ffff00;
+                 box-shadow: 
+                     0 0 30px rgba(255, 255, 0, 0.3),
+                     inset 0 0 20px rgba(0, 0, 0, 0.7);
+             }
+             100% { 
+                 text-shadow: 
+                     0 0 8px #000,
+                     0 0 15px #000,
+                     0 0 20px #000,
+                     0 0 25px #000,
+                     0 0 15px #ffff00,
+                     0 0 25px #ffff00,
+                     0 0 35px #ffff00,
+                     0 0 45px #ffff00,
+                     0 0 55px #ffff00;
+                 box-shadow: 
+                     0 0 40px rgba(255, 255, 0, 0.6),
+                     inset 0 0 20px rgba(0, 0, 0, 0.7);
+             }
+         }
+         
+         .winner-name {
+             color: #00f5ff;
+             font-size: 1.2em;
+             margin-top: 1vh;
+         }
+         
+         .winner-time {
+             color: #39ff14;
+             font-size: 0.8em;
+             margin-top: 0.5vh;
+             font-weight: 700;
+         }
+         
+         @media (max-width: 768px) {
+             .cyber-winner { font-size: 8vw; padding: 2vh; }
+         }
+         </style>
+         
+         <div class="cyber-winner">
+             üèÜ GANADOR
+             <div class="winner-name">${this.game.winner.toUpperCase()}</div>
+             <div class="winner-time">‚è±Ô∏è TIEMPO: ${this.game.winnerSecs}s</div>
+         </div>`;
+ 
+     const winnerElement = this.add.dom(w / 2, h / 3).createFromHTML(winnerHtml);
+     winnerElement.setOrigin(0.5, 0.5);
+     winnerElement.setDepth(10);
+     winnerElement.setAlpha(0);
+     winnerElement.setScale(0.8);
+ 
+     // Animate entrance
      this.add.tween({
-       targets: winnerText,
+       targets: winnerElement,
+       alpha: 1,
        scale: 1,
-       duration: 500,
-       ease: 'Sine.easeInOut',
+       duration: 800,
+       ease: 'Back.easeOut',
      });
    }
```

</details>

---

## Todo List

- [x] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
- [x] Convertir texto del ganador a DOM element con estilos neon
- [-] Convertir resumen de resultados a lista estilizada con tarjetas
- [ ] Reemplazar botones con elementos DOM cyberpunk
- [ ] Implementar animaciones de entrada mejoradas

---

Ahora voy a convertir el resumen de resultados a una lista estilizada con tarjetas:


---

<details><summary>Edit file: src/phaser-ui/scenes/ending-scene.js</summary>

undefined

**Chunk 1**
Lines added: 174, lines removed: 20

```diff
@@ -361,26 +361,180 @@
  
    addSummary (w, h) {
-     const summaryText = this.game.getSummary()
-       .map((s) => `${s.player}: ${s.secs} segs.`)
-       .join('\n');
- 
-     const summary = this.make.text({
-       x: w / 2,
-       y: h / 2,
-       text: summaryText,
-       style: {
-         font: '4vw monospace',
-         fill: '#000000',
-         align: 'center',
-       },
-     }).setOrigin(0.5, 0.5)
-       .setScale(0);
- 
+     const summary = this.game.getSummary();
+     const colors = ['#00f5ff', '#ff0080', '#39ff14', '#ffff00', '#ff6600', '#00cccc', '#6600cc', '#cccc00'];
+     
+     // Create cyberpunk results summary using DOM element
+     const summaryHtml = `
+         <style>
+         .cyber-summary {
+             font-family: 'Orbitron', 'Courier New', monospace;
+             text-align: center;
+             max-width: 90vw;
+             margin: 0 auto;
+         }
+         
+         .summary-title {
+             font-size: 4vw;
+             font-weight: 900;
+             color: #00f5ff;
+             text-transform: uppercase;
+             letter-spacing: 2px;
+             margin-bottom: 3vh;
+             text-shadow: 
+                 0 0 5px #000,
+                 0 0 10px #000,
+                 0 0 15px #000,
+                 0 0 20px #000,
+                 0 0 10px #00f5ff,
+                 0 0 20px #00f5ff,
+                 0 0 30px #00f5ff;
+         }
+         
+         .player-result {
+             display: flex;
+             justify-content: space-between;
+             align-items: center;
+             padding: 2vh 3vw;
+             margin: 1vh auto;
+             border-radius: 12px;
+             font-size: 3.5vw;
+             font-weight: 700;
+             text-transform: uppercase;
+             letter-spacing: 1px;
+             text-shadow: 
+                 0 0 2px #000,
+                 0 0 4px #000;
+             border: 2px solid;
+             box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
+             max-width: 80vw;
+             transition: all 0.3s ease;
+         }
+         
+         .player-result:hover {
+             transform: translateY(-3px) scale(1.02);
+         }
+         
+         .player-name {
+             flex: 1;
+             text-align: left;
+         }
+         
+         .player-time {
+             flex: 1;
+             text-align: right;
+             font-weight: 900;
+         }
+         
+         .player-result.color-0 {
+             background: linear-gradient(135deg, #00f5ff, #0099cc);
+             border-color: #00f5ff;
+             color: white;
+             box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
+         }
+         
+         .player-result.color-1 {
+             background: linear-gradient(135deg, #ff0080, #cc0066);
+             border-color: #ff0080;
+             color: white;
+             box-shadow: 0 0 30px rgba(255, 0, 128, 0.3);
+         }
+         
+         .player-result.color-2 {
+             background: linear-gradient(135deg, #39ff14, #2ecc40);
+             border-color: #39ff14;
+             color: white;
+             box-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
+         }
+         
+         .player-result.color-3 {
+             background: linear-gradient(135deg, #ffff00, #cccc00);
+             border-color: #ffff00;
+             color: black;
+             box-shadow: 0 0 30px rgba(255, 255, 0, 0.3);
+         }
+         
+         .player-result.color-4 {
+             background: linear-gradient(135deg, #ff6600, #cc5500);
+             border-color: #ff6600;
+             color: white;
+             box-shadow: 0 0 30px rgba(255, 102, 0, 0.3);
+         }
+         
+         .player-result.color-5 {
+             background: linear-gradient(135deg, #00cccc, #00aaaa);
+             border-color: #00cccc;
+             color: white;
+             box-shadow: 0 0 30px rgba(0, 204, 204, 0.3);
+         }
+         
+         .player-result.color-6 {
+             background: linear-gradient(135deg, #6600cc, #5500aa);
+             border-color: #6600cc;
+             color: white;
+             box-shadow: 0 0 30px rgba(102, 0, 204, 0.3);
+         }
+         
+         .player-result.color-7 {
+             background: linear-gradient(135deg, #cccc00, #aaaa00);
+             border-color: #cccc00;
+             color: black;
+             box-shadow: 0 0 30px rgba(204, 204, 0, 0.3);
+         }
+         
+         @media (max-width: 768px) {
+             .summary-title { font-size: 5vw; }
+             .player-result { font-size: 4.5vw; padding: 1.5vh 2vw; }
+         }
+         </style>
+         
+         <div class="cyber-summary">
+             <div class="summary-title">üìä RESULTADOS FINALES</div>
+             ${summary.map((s, index) => `
+                 <div class="player-result color-${index % 8}">
+                     <div class="player-name">${s.player.toUpperCase()}</div>
+                     <div class="player-time">${s.secs}s</div>
+                 </div>
+             `).join('')}
+         </div>`;
+ 
+     const summaryElement = this.add.dom(w / 2, h / 2 + 50).createFromHTML(summaryHtml);
+     summaryElement.setOrigin(0.5, 0.5);
+     summaryElement.setDepth(10);
+     summaryElement.setAlpha(0);
+     summaryElement.setScale(0.9);
+ 
+     // Animate entrance with staggered effect for each player
      this.add.tween({
-       targets: summary,
+       targets: summaryElement,
+       alpha: 1,
        scale: 1,
-       duration: 500,
-       ease: 'Sine.easeInOut',
-     });
+       duration: 600,
+       ease: 'Back.easeOut',
+     });
+ 
+     // Add individual card animations with delay
+     const playerCards = summaryElement.node.querySelectorAll('.player-result');
+     playerCards.forEach((card, index) => {
+       const delay = 100 * index;
+       setTimeout(() => {
+         card.style.animation = 'slideInUp 0.5s ease-out forwards';
+       }, delay);
+     });
+ 
+     // Add CSS animation for individual cards
+     const style = document.createElement('style');
+     style.textContent = `
+       @keyframes slideInUp {
+         from {
+           opacity: 0;
+           transform: translateY(30px);
+         }
+         to {
+           opacity: 1;
+           transform: translateY(0);
+         }
+       }
+     `;
+     document.head.appendChild(style);
    }
  }
```

</details>

---

## Todo List

- [x] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
- [x] Convertir texto del ganador a DOM element con estilos neon
- [x] Convertir resumen de resultados a lista estilizada con tarjetas
- [-] Reemplazar botones con elementos DOM cyberpunk
- [ ] Implementar animaciones de entrada mejoradas

---

Ahora voy a reemplazar los botones con elementos DOM cyberpunk:


---

<details><summary>Edit file: src/phaser-ui/scenes/ending-scene.js</summary>

undefined

**Chunk 1**
Lines added: 92, lines removed: 9

```diff
@@ -228,13 +228,96 @@
  
    addRestartButton (w, h) {
-     const restart = this.add.text(w / 2, 3 / 4 * h, 'Continuar', {
-       font: '4vh monospace',
-       fill: '#444444',
-     }).setInteractive();
- 
-     restart.setOrigin(0.5);
-     restart.on('pointerup', () => {
-       this.scene.stop();
-       this.onRestart();
+     // Create cyberpunk restart button using DOM element
+     const restartButtonHtml = `
+         <style>
+         .cyber-restart-button {
+             background: linear-gradient(45deg, #ff0080, #00f5ff);
+             border: none;
+             padding: 20px;
+             font-size: 5vw;
+             font-family: 'Orbitron', monospace;
+             font-weight: 900;
+             color: #000;
+             cursor: pointer;
+             transition: all 0.3s ease;
+             text-transform: uppercase;
+             letter-spacing: 2px;
+             overflow: hidden;
+             border-radius: 8px;
+             box-shadow: 
+                 0 0 30px rgba(0, 245, 255, 0.5),
+                 0 5px 15px rgba(0, 0, 0, 0.3);
+             width: 90vw;
+             max-width: 500px;
+             position: relative;
+         }
+         
+         .cyber-restart-button::before {
+             content: '';
+             position: absolute;
+             top: 0;
+             left: -100%;
+             width: 100%;
+             height: 100%;
+             background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
+             transition: left 0.5s;
+         }
+         
+         .cyber-restart-button:hover::before {
+             left: 100%;
+         }
+         
+         .cyber-restart-button:hover {
+             transform: translateY(-2px) scale(1.02);
+             box-shadow: 
+                 0 0 50px rgba(0, 245, 255, 0.8),
+                 0 10px 25px rgba(0, 0, 0, 0.5);
+         }
+         
+         .cyber-restart-button:active {
+             transform: translateY(0) scale(0.98);
+         }
+         
+         @media (max-width: 768px) {
+             .cyber-restart-button {
+                 font-size: 6vw;
+                 padding: 18px;
+             }
+         }
+         
+         @media (max-height: 600px) {
+             .cyber-restart-button {
+                 font-size: 4vw;
+                 padding: 15px;
+             }
+         }
+         </style>
+         
+         <button class="cyber-restart-button" id="cyberRestartButton">
+             üîÑ CONTINUAR MATCH
+         </button>`;
+ 
+     const restartButtonElement = this.add.dom(w / 2, 3 / 4 * h).createFromHTML(restartButtonHtml);
+     restartButtonElement.setOrigin(0.5, 0.5);
+     restartButtonElement.setDepth(100);
+     restartButtonElement.setAlpha(0);
+     restartButtonElement.setScale(0.8);
+ 
+     // Add click event
+     restartButtonElement.addListener('click');
+     restartButtonElement.on('click', (event) => {
+       if (event.target.id === 'cyberRestartButton') {
+         this.scene.stop();
+         this.onRestart();
+       }
+     });
+ 
+     // Animate entrance
+     this.add.tween({
+       targets: restartButtonElement,
+       alpha: 1,
+       scale: 1,
+       duration: 600,
+       ease: 'Back.easeOut',
      });
    }
```

</details>

---

Ahora voy a reemplazar el bot√≥n de terminar:


---

<details><summary>Edit file: src/phaser-ui/scenes/ending-scene.js</summary>

undefined

**Chunk 1**
Lines added: 95, lines removed: 10

```diff
@@ -324,14 +324,99 @@
  
    addEndButton (w, h) {
-     const end = this.add.text(w / 2, 3 / 4 * h, 'Terminar', {
-       font: '4vh monospace',
-       fill: '#990000',
-     }).setInteractive();
- 
-     end.setOrigin(0.5);
-     end.on('pointerup', async () => {
-       this.scene.stop();
-       await this.onEnd();
-       window.location.reload();
+     // Create cyberpunk end button using DOM element
+     const endButtonHtml = `
+         <style>
+         .cyber-end-button {
+             background: linear-gradient(45deg, #ff3300, #ff6600);
+             border: none;
+             padding: 20px;
+             font-size: 5vw;
+             font-family: 'Orbitron', monospace;
+             font-weight: 900;
+             color: #fff;
+             cursor: pointer;
+             transition: all 0.3s ease;
+             text-transform: uppercase;
+             letter-spacing: 2px;
+             overflow: hidden;
+             border-radius: 8px;
+             box-shadow: 
+                 0 0 30px rgba(255, 51, 0, 0.5),
+                 0 5px 15px rgba(0, 0, 0, 0.3);
+             width: 90vw;
+             max-width: 500px;
+             position: relative;
+             text-shadow: 0 0 5px #000;
+         }
+         
+         .cyber-end-button::before {
+             content: '';
+             position: absolute;
+             top: 0;
+             left: -100%;
+             width: 100%;
+             height: 100%;
+             background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
+             transition: left 0.5s;
+         }
+         
+         .cyber-end-button:hover::before {
+             left: 100%;
+         }
+         
+         .cyber-end-button:hover {
+             transform: translateY(-2px) scale(1.02);
+             box-shadow: 
+                 0 0 50px rgba(255, 51, 0, 0.8),
+                 0 10px 25px rgba(0, 0, 0, 0.5);
+             background: linear-gradient(45deg, #ff4400, #ff7700);
+         }
+         
+         .cyber-end-button:active {
+             transform: translateY(0) scale(0.98);
+         }
+         
+         @media (max-width: 768px) {
+             .cyber-end-button {
+                 font-size: 6vw;
+                 padding: 18px;
+             }
+         }
+         
+         @media (max-height: 600px) {
+             .cyber-end-button {
+                 font-size: 4vw;
+                 padding: 15px;
+             }
+         }
+         </style>
+         
+         <button class="cyber-end-button" id="cyberEndButton">
+             üèÅ TERMINAR PARTIDA
+         </button>`;
+ 
+     const endButtonElement = this.add.dom(w / 2, 3 / 4 * h).createFromHTML(endButtonHtml);
+     endButtonElement.setOrigin(0.5, 0.5);
+     endButtonElement.setDepth(100);
+     endButtonElement.setAlpha(0);
+     endButtonElement.setScale(0.8);
+ 
+     // Add click event
+     endButtonElement.addListener('click');
+     endButtonElement.on('click', async (event) => {
+       if (event.target.id === 'cyberEndButton') {
+         this.scene.stop();
+         await this.onEnd();
+         window.location.reload();
+       }
+     });
+ 
+     // Animate entrance
+     this.add.tween({
+       targets: endButtonElement,
+       alpha: 1,
+       scale: 1,
+       duration: 600,
+       ease: 'Back.easeOut',
      });
    }
```

</details>

---

## Todo List

- [x] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
- [x] Convertir texto del ganador a DOM element con estilos neon
- [x] Convertir resumen de resultados a lista estilizada con tarjetas
- [x] Reemplazar botones con elementos DOM cyberpunk
- [x] Implementar animaciones de entrada mejoradas

---

Ahora voy a verificar si hay errores de linting en el archivo:


---



---

¬°Perfecto! He completado la implementaci√≥n del redise√±o neon/cyber de la pantalla de finalizaci√≥n. Vamos a hacer una prueba r√°pida para asegurarnos de que todo funciona correctamente:


---

```bash
cd /Users/jmarti/Development/personal/triangulame && npm run build
```

```

> triangles-app@0.0.1 build
> vite build

You are using Node.js 20.10.0. Vite requires Node.js version 20.19+ or 22.12+. Please upgrade your Node.js version.
vite v7.1.7 building for production...
‚úì 0 modules transformed.
‚úó Build failed in 18ms
error during build:
[vite:build-html] crypto.hash is not a function
file: /Users/jmarti/Development/personal/triangulame/index.html
    at getHash (file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:2621:21)
    at file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26646:22
    at traverseNodes (file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26416:2)
    at file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26417:141
    at Array.forEach (<anonymous>)
    at traverseNodes (file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26417:118)
    at file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26417:141
    at Array.forEach (<anonymous>)
    at traverseNodes (file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26417:118)
    at file:///Users/jmarti/Development/personal/triangulame/node_modules/vite/dist/node/chunks/dep-Bm2ujbhY.js:26417:141

```

---

_**User (2025-09-24 09:29Z)**_

/commit 

--- Cursor Command: commit.md ---
Haz commit y push directamente.

Para obtener el mensaje, revisa las diferencias existentes en los ficheros (puedes hacer un git diff --cached, tras hacer add de todos los ficheros), y complementa lo que se ha hecho (el what) con la intenci√≥n (el why) a trav√©s de la conversaci√≥n actual.

El mensaje debe ser la continuaci√≥n de la siguiente frase: "este commit hace que...", y usa verbo presente, por ejemplo "el asesino puede lanzar bombas"; pero no debe incluir la frase "este commit hace que".

Solo usa una frase. 

Utiliza tambi√©n "feat:" o "bugfix" o "refactor" al principio del mensaje.

El commit debe ser una √∫nica linea.
--- End Command ---

---

_**Assistant**_

Voy a revisar los cambios y hacer el commit con push.


---

```bash
git add .
```

---

```bash
git diff --cached
```

```
diff --git "a/.specstory/history/2025-09-24_12-37Z-adaptar-pantalla-para-coherencia-de-dise\303\261o.md" "b/.specstory/history/2025-09-24_12-37Z-adaptar-pantalla-para-coherencia-de-dise\303\261o.md"
new file mode 100644
index 0000000..d61c10c
--- /dev/null
+++ "b/.specstory/history/2025-09-24_12-37Z-adaptar-pantalla-para-coherencia-de-dise\303\261o.md"
@@ -0,0 +1,125 @@
+<!-- Generated by SpecStory -->
+
+# Adaptar pantalla para coherencia de dise√±o (2025-09-24 12:37Z)
+
+_**User (2025-09-24 09:29Z)**_
+
+/plan-feature 
+
+Teniendo en cuenta el redise√±o que hemos hecho por ejemplo en @0006_PLAN.md , @0005_PLAN.md o @0004_PLAN.md basado en @neon-cyber-design.html , queda la pantalla de @ending-scene.js . ¬øPuedes adaptarla para que tenga coherencia con @welcome-scene.js o @players-scene.js ?
+
+--- Cursor Command: plan-feature.md ---
+El usuario proporcionar√° una descripci√≥n de una funcionalidad. Tu trabajo es:
+
+1. Crear un plan t√©cnico que describa de forma concisa la funcionalidad que el usuario quiere construir.
+2. Investigar los archivos y funciones que deben cambiarse para implementar la funcionalidad
+3. Evitar cualquier secci√≥n al estilo de product manager (sin criterios de √©xito, cronograma, migraci√≥n, etc)
+4. Evitar escribir cualquier c√≥digo real en el plan.
+5. Incluir detalles espec√≠ficos y textuales del prompt del usuario para garantizar que el plan sea preciso.
+
+Esto es estrictamente un documento de requisitos t√©cnicos que debe:
+
+1. Incluir una breve descripci√≥n para establecer el contexto al principio
+2. Se√±alar todos los archivos y funciones relevantes que deban cambiarse o crearse
+3. Explicar cualquier algoritmo que se utilice paso a paso
+4. Si es necesario, dividir el trabajo en fases l√≥gicas. Idealmente, esto deber√≠a hacerse de manera que tenga una fase inicial de ‚Äúcapa de datos‚Äù que defina los tipos y los cambios de base de datos que deben ejecutarse, seguida de N fases que puedan hacerse en paralelo (p. ej., Fase 2A - UI, Fase 2B - API). Solo incluye fases si es una funcionalidad REALMENTE grande.
+
+Si los requisitos del usuario no est√°n claros, especialmente despu√©s de investigar los archivos relevantes, puedes hacer hasta 5 preguntas de clarificaci√≥n antes de escribir el plan. Si lo haces, incorpora las respuestas del usuario en el plan.
+
+Prioriza ser conciso y preciso. Haz el plan lo m√°s ajustado posible sin perder ninguno de los detalles cr√≠ticos de los requisitos del usuario.
+
+Escribe el plan en un archivo docs/features/<N>_PLAN.md con el siguiente n√∫mero de funcionalidad disponible (empezando por 0001)
+--- End Command ---
+
+---
+
+_**Assistant**_
+
+Voy a investigar el estado actual de `ending-scene.js` y compararlo con el dise√±o neon/cyber implementado en las otras escenas para crear un plan coherente.
+
+
+---
+
+Read file: undefined
+
+---
+
+Read file: undefined
+
+---
+
+Read file: undefined
+
+---
+
+Ahora voy a verificar qu√© archivos de plan ya existen para determinar el siguiente n√∫mero:
+
+
+---
+
+<details>
+            <summary>Listed directory undefined ‚Ä¢ **0** results</summary>
+        
+No results found
+</details>
+
+---
+
+Perfecto, ahora voy a crear el plan para el redise√±o neon/cyber de la escena de finalizaci√≥n:
+
+
+---
+
+
+
+---
+
+He creado el plan t√©cnico para el redise√±o neon/cyber de la pantalla de finalizaci√≥n (`EndingScene`). El plan est√° dise√±ado para mantener coherencia visual completa con las escenas de bienvenida y jugadores ya redise√±adas.
+
+**Puntos clave del plan:**
+
+1. **Reutilizaci√≥n de c√≥digo probado**: Utiliza las mismas implementaciones de fondo cyberpunk que ya funcionan en `welcome-scene.js` y `players-scene.js`
+
+2. **Conversi√≥n a DOM elements**: Cambia de `this.make.text()` a elementos DOM con HTML/CSS para obtener el control total sobre los estilos neon
+
+3. **Paleta coherente**: Usa los mismos colores (cian, magenta, verde, amarillo) y efectos glow que las otras escenas
+
+4. **Funcionalidad intacta**: Preserva toda la l√≥gica de finalizaci√≥n de partida, solo cambia la presentaci√≥n visual
+
+5. **Animaciones mejoradas**: Implementa transiciones m√°s elaboradas y efectos de entrada escalonados
+
+El plan est√° estructurado para ser implementado de forma incremental, reutilizando c√≥digo existente y manteniendo la coherencia visual en todo el juego.
+
+---
+
+_**User (2025-09-24 09:29Z)**_
+
+implementa!
+
+---
+
+_**Assistant**_
+
+¬°Perfecto! Voy a implementar el redise√±o neon/cyber de la pantalla de finalizaci√≥n siguiendo el plan que acabamos de crear.
+
+
+---
+
+## Todo List
+
+- [-] A√±adir fondo cyberpunk con grid animado y part√≠culas flotantes
+- [ ] Convertir texto del ganador a DOM element con estilos neon
+- [ ] Convertir resumen de resultados a lista estilizada con tarjetas
+- [ ] Reemplazar botones con elementos DOM cyberpunk
+- [ ] Implementar animaciones de entrada mejoradas
+
+---
+
+
+
+---
+
+
+
+---
+
diff --git a/docs/features/0007_PLAN.md b/docs/features/0007_PLAN.md
new file mode 100644
index 0000000..45fc6c7
--- /dev/null
+++ b/docs/features/0007_PLAN.md
@@ -0,0 +1,114 @@
+## 0007 ‚Äì Redise√±o neon/cyber de la pantalla de finalizaci√≥n (EndingScene)
+
+### Descripci√≥n breve
+Actualizar la UI de `src/phaser-ui/scenes/ending-scene.js` para que adopte la est√©tica neon/cyber coherente con `welcome-scene.js` y `players-scene.js`: fondo con grid animado, tipograf√≠a Orbitron, colores vibrantes con efecto glow, part√≠culas flotantes, y elementos UI estilizados. Mantener intacta la l√≥gica de finalizaci√≥n de partida y mostrar informaci√≥n del ganador y resumen de resultados.
+
+### Archivos a modificar
+- `src/phaser-ui/scenes/ending-scene.js`
+  - A√±adir `createCyberBackground()` con grid animado, gradientes y part√≠culas flotantes.
+  - Convertir `addWinner()` y `addSummary()` para usar DOM elements con estilos cyberpunk.
+  - Reemplazar `addRestartButton()` y `addEndButton()` con botones cyberpunk estilizados.
+  - Implementar animaciones de entrada mejoradas y efectos visuales neon.
+
+### Cambios propuestos en EndingScene
+
+1) Fondo cyberpunk (create)
+   - `this.createCyberBackground()`
+     - Reutilizar implementaci√≥n id√©ntica de `welcome-scene.js` y `players-scene.js`:
+       - `createGradientBackground()` con gradientes 0x0f0f23 ‚Üí 0x1a1a2e ‚Üí 0x16213e
+       - `createRadialGlows()` con tri√°ngulos neon en cian (#00f5ff), magenta (#ff0080) y verde (#39ff14)
+       - `createAnimatedGrid()` con l√≠neas cian animadas de 50px
+       - `createFloatingParticles()` con tri√°ngulos de colores flotantes
+
+2) Texto del ganador estilizado
+   - `addWinner(w, h)`
+     - Convertir de `this.make.text()` a DOM element con HTML/CSS cyberpunk
+     - Usar tipograf√≠a Orbitron, color amarillo (#ffff00) para el ganador
+     - Aplicar `text-shadow` con m√∫ltiples capas para efecto glow
+     - Mantener animaci√≥n de entrada con `scale: 0 ‚Üí 1`
+     - Formato: "üèÜ GANADOR: {nombre}\n‚è±Ô∏è TIEMPO: {segundos}s"
+
+3) Resumen de resultados estilizado
+   - `addSummary(w, h)`
+     - Convertir a DOM element con lista de jugadores estilizada
+     - Cada jugador en tarjeta individual con color seg√∫n posici√≥n
+     - Usar colores de la paleta neon: cian, magenta, verde, amarillo, naranja, etc.
+     - Aplicar `border-radius`, `box-shadow` y efectos glow
+     - Mantener animaci√≥n de entrada escalonada
+
+4) Botones de acci√≥n cyberpunk
+   - `addRestartButton(w, h)`
+     - Reemplazar `this.add.text()` por DOM element
+     - Usar estilo id√©ntico a botones de `welcome-scene.js`
+     - Gradiente magenta-cyan, tipograf√≠a Orbitron, efectos hover
+     - Texto: "üîÑ CONTINUAR MATCH"
+   
+   - `addEndButton(w, h)`
+     - Mismo estilo que `addRestartButton()` pero con colores m√°s intensos
+     - Gradiente rojo-naranja para indicar finalizaci√≥n
+     - Texto: "üèÅ TERMINAR PARTIDA"
+     - Efecto glow m√°s pronunciado
+
+5) Animaciones y transiciones
+   - Implementar animaciones de entrada m√°s elaboradas
+   - Usar `setAlpha(0)` inicial y `tween` para fade-in
+   - A√±adir efectos de "screen shake" opcional en transiciones importantes
+   - Coordinar timing de animaciones para entrada escalonada
+
+### Algoritmo/flujo visual (paso a paso)
+
+1) create
+   - `createCyberBackground()` ‚Üí fondo completo con grid, gradientes y part√≠culas
+   - `addWinner()` ‚Üí texto ganador con DOM cyberpunk
+   - `addSummary()` ‚Üí lista de resultados estilizada
+   - Evaluar `game.numGame < ENDING_GAME_NUMBER`
+   - `addRestartButton()` O `addEndButton()` seg√∫n condici√≥n
+
+2) Animaciones de entrada
+   - Fade-in del fondo (500ms)
+   - Escala del texto ganador (500ms, delay 200ms)
+   - Entrada escalonada de resumen (300ms cada elemento, delay 400ms)
+   - Entrada del bot√≥n final (400ms, delay 800ms)
+
+3) Interacciones
+   - Hover effects en botones con transform y glow
+   - Click handlers mantienen l√≥gica original
+   - Transiciones suaves en todas las interacciones
+
+### Elementos visuales espec√≠ficos
+
+**Paleta de colores:**
+- Ganador: #ffff00 (amarillo neon)
+- Resumen jugadores: colores rotativos de paleta cyberpunk
+- Bot√≥n continuar: gradiente #ff0080 ‚Üí #00f5ff
+- Bot√≥n terminar: gradiente #ff3300 ‚Üí #ff6600
+- Fondos: #0f0f23, #1a1a2e, #16213e
+
+**Tipograf√≠a:**
+- Fuente: 'Orbitron' (ya cargada en otras escenas)
+- Tama√±os responsive: vw/vh para escalado
+- Peso: 700-900 para t√≠tulos, 400 para texto
+
+**Efectos:**
+- Text-shadow m√∫ltiples capas para glow
+- Box-shadow con colores neon
+- Transform hover (scale, translateY)
+- Blend modes ADD para elementos glow
+
+### Consideraciones de rendimiento
+- Reutilizar implementaciones probadas de otras escenas
+- Mantener n√∫mero de part√≠culas bajo (< 15)
+- Usar DOM elements solo para UI, Graphics para efectos
+- Evitar recreaciones innecesarias en animaciones
+
+### Impacto en funcionalidad
+- Ninguno. Todos los cambios son visuales.
+- Mantener callbacks `onRestart` y `onEnd` intactos
+- Preservar l√≥gica de `game.numGame < ENDING_GAME_NUMBER`
+- Conservar comportamiento de `window.location.reload()`
+
+### Coherencia visual
+- Estilo id√©ntico a `welcome-scene.js` y `players-scene.js`
+- Misma paleta de colores y efectos
+- Tipograf√≠a y espaciado consistentes
+- Transiciones y animaciones coherentes con el resto del juego
diff --git a/src/phaser-ui/scenes/ending-scene.js b/src/phaser-ui/scenes/ending-scene.js
index 04af468..ce2069e 100644
--- a/src/phaser-ui/scenes/ending-scene.js
+++ b/src/phaser-ui/scenes/ending-scene.js
@@ -18,86 +18,692 @@ class EndingScene extends Phaser.Scene {
   create () {
     const w = this.cameras.main.width;
     const h = this.cameras.main.height;
-    this.addWinner(w, h);
-    this.addSummary(w, h);
-    if (this.game.numGame < ENDING_GAME_NUMBER) {
-      this.addRestartButton(w, h);
-    } else {
-      this.addEndButton(w, h);
+    
+    // Crear fondo cyberpunk
+    this.createCyberBackground();
+    
+    // A√±adir elementos con animaciones escalonadas
+    this.time.delayedCall(200, () => this.addWinner(w, h));
+    this.time.delayedCall(400, () => this.addSummary(w, h));
+    this.time.delayedCall(800, () => {
+      if (this.game.numGame < ENDING_GAME_NUMBER) {
+        this.addRestartButton(w, h);
+      } else {
+        this.addEndButton(w, h);
+      }
+    });
+  }
+
+  createCyberBackground() {
+    const w = this.cameras.main.width;
+    const h = this.cameras.main.height;
+
+    // Create base background with simulated gradient
+    this.createGradientBackground(w, h);
+
+    // Add radial gradient spots for neon effect
+    this.createRadialGlows(w, h);
+
+    // Create animated grid
+    this.createAnimatedGrid(w, h);
+
+    // Create floating particles
+    this.createFloatingParticles(w, h);
+  }
+
+  createGradientBackground(w, h) {
+    // Create a simpler gradient background using fillGradientStyle
+    const backgroundGraphics = this.add.graphics();
+    
+    // Use Phaser's built-in gradient support
+    backgroundGraphics.fillGradientStyle(0x0f0f23, 0x0f0f23, 0x16213e, 0x1a1a2e, 1);
+    backgroundGraphics.fillRect(0, 0, w, h);
+
+    // Add a second layer for more depth
+    const overlayGraphics = this.add.graphics();
+    overlayGraphics.fillGradientStyle(0x1a1a2e, 0x16213e, 0x0f0f23, 0x1a1a2e, 0.7);
+    overlayGraphics.fillRect(0, 0, w, h);
+    overlayGraphics.setBlendMode(Phaser.BlendModes.OVERLAY);
+  }
+
+  createRadialGlows(w, h) {
+    // Cyan triangle glow at 20% 50%
+    this.drawTriangleGlow(w * 0.2, h * 0.5, w * 0.2, 0, 0x00f5ff);
+
+    // Magenta triangle glow at 80% 20% (rotated)
+    this.drawTriangleGlow(w * 0.8, h * 0.2, w * 0.15, Math.PI / 3, 0xff0080);
+
+    // Green triangle glow at 40% 80% (different rotation)
+    this.drawTriangleGlow(w * 0.4, h * 0.8, w * 0.18, -Math.PI / 4, 0x39ff14);
+  }
+
+  drawTriangleGlow(centerX, centerY, size, rotation, color) {
+    // Create multiple triangle layers for glow effect
+    const numLayers = 6;
+    
+    for (let i = 0; i < numLayers; i++) {
+      const graphics = this.add.graphics();
+      const layerSize = size * (1 + i * 0.4);
+      const layerAlpha = 0.3 - (i * 0.04); // Start with higher alpha
+      
+      graphics.fillStyle(color, layerAlpha);
+      graphics.setBlendMode(Phaser.BlendModes.ADD);
+      
+      // Calculate triangle points
+      const angle1 = rotation;
+      const angle2 = rotation + (2 * Math.PI / 3);
+      const angle3 = rotation + (4 * Math.PI / 3);
+      
+      const x1 = centerX + Math.cos(angle1) * layerSize;
+      const y1 = centerY + Math.sin(angle1) * layerSize;
+      const x2 = centerX + Math.cos(angle2) * layerSize;
+      const y2 = centerY + Math.sin(angle2) * layerSize;
+      const x3 = centerX + Math.cos(angle3) * layerSize;
+      const y3 = centerY + Math.sin(angle3) * layerSize;
+      
+      // Draw triangle
+      graphics.beginPath();
+      graphics.moveTo(x1, y1);
+      graphics.lineTo(x2, y2);
+      graphics.lineTo(x3, y3);
+      graphics.closePath();
+      graphics.fillPath();
+    }
+  }
+
+  createAnimatedGrid(w, h) {
+    const gridSize = 50;
+    const gridGraphics = this.add.graphics();
+    gridGraphics.lineStyle(1, 0x00f5ff, 0.1);
+
+    // Create vertical lines
+    for (let x = 0; x <= w + gridSize; x += gridSize) {
+      gridGraphics.moveTo(x, 0);
+      gridGraphics.lineTo(x, h + gridSize);
+    }
+
+    // Create horizontal lines
+    for (let y = 0; y <= h + gridSize; y += gridSize) {
+      gridGraphics.moveTo(0, y);
+      gridGraphics.lineTo(w + gridSize, y);
+    }
+
+    gridGraphics.strokePath();
+
+    // Animate the grid
+    this.tweens.add({
+      targets: gridGraphics,
+      x: -gridSize,
+      y: -gridSize,
+      duration: 20000,
+      repeat: -1,
+      ease: 'Linear'
+    });
+  }
+
+  createFloatingParticles(w, h) {
+    const colors = [0x00f5ff, 0xff0080, 0x39ff14, 0xffff00];
+    const particles = [];
+
+    // Create 12 triangle particles
+    for (let i = 0; i < 12; i++) {
+      const particle = this.add.graphics();
+      const color = colors[i % colors.length];
+      const size = Phaser.Math.Between(2, 4);
+      
+      particle.fillStyle(color, 0.8);
+      
+      // Draw small triangle
+      particle.beginPath();
+      particle.moveTo(0, -size);
+      particle.lineTo(-size, size);
+      particle.lineTo(size, size);
+      particle.closePath();
+      particle.fillPath();
+      
+      // Random starting position
+      particle.x = Phaser.Math.Between(0, w);
+      particle.y = h + 50;
+      
+      particles.push(particle);
+
+      // Animate particle floating up
+      const delay = Phaser.Math.Between(0, 6000);
+      const duration = Phaser.Math.Between(4000, 8000);
+
+      this.time.delayedCall(delay, () => {
+        this.animateParticle(particle, w, h, duration);
+      });
     }
+
+    this.particles = particles;
+  }
+
+  animateParticle(particle, w, h, duration) {
+    // Reset particle position
+    particle.x = Phaser.Math.Between(0, w);
+    particle.y = h + 50;
+    particle.alpha = 0;
+
+    // Create floating animation
+    this.tweens.add({
+      targets: particle,
+      y: -50,
+      alpha: 1,
+      duration: duration,
+      ease: 'Sine.easeInOut',
+      onComplete: () => {
+        // Restart animation
+        const newDuration = Phaser.Math.Between(4000, 8000);
+        this.animateParticle(particle, w, h, newDuration);
+      }
+    });
+
+    // Add rotation
+    this.tweens.add({
+      targets: particle,
+      rotation: Math.PI * 2,
+      duration: duration,
+      ease: 'Linear'
+    });
+
+    // Add fade out at the end
+    this.tweens.add({
+      targets: particle,
+      alpha: 0,
+      duration: 1000,
+      delay: duration - 1000,
+      ease: 'Sine.easeIn'
+    });
+
+    // Add fade in at the beginning
+    this.tweens.add({
+      targets: particle,
+      alpha: 1,
+      duration: 1000,
+      delay: 500,
+      ease: 'Sine.easeOut'
+    });
   }
 
   addRestartButton (w, h) {
-    const restart = this.add.text(w / 2, 3 / 4 * h, 'Continuar', {
-      font: '4vh monospace',
-      fill: '#444444',
-    }).setInteractive();
-
-    restart.setOrigin(0.5);
-    restart.on('pointerup', () => {
-      this.scene.stop();
-      this.onRestart();
+    // Create cyberpunk restart button using DOM element
+    const restartButtonHtml = `
+        <style>
+        .cyber-restart-button {
+            background: linear-gradient(45deg, #ff0080, #00f5ff);
+            border: none;
+            padding: 20px;
+            font-size: 5vw;
+            font-family: 'Orbitron', monospace;
+            font-weight: 900;
+            color: #000;
+            cursor: pointer;
+            transition: all 0.3s ease;
+            text-transform: uppercase;
+            letter-spacing: 2px;
+            overflow: hidden;
+            border-radius: 8px;
+            box-shadow: 
+                0 0 30px rgba(0, 245, 255, 0.5),
+                0 5px 15px rgba(0, 0, 0, 0.3);
+            width: 90vw;
+            max-width: 500px;
+            position: relative;
+        }
+        
+        .cyber-restart-button::before {
+            content: '';
+            position: absolute;
+            top: 0;
+            left: -100%;
+            width: 100%;
+            height: 100%;
+            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
+            transition: left 0.5s;
+        }
+        
+        .cyber-restart-button:hover::before {
+            left: 100%;
+        }
+        
+        .cyber-restart-button:hover {
+            transform: translateY(-2px) scale(1.02);
+            box-shadow: 
+                0 0 50px rgba(0, 245, 255, 0.8),
+                0 10px 25px rgba(0, 0, 0, 0.5);
+        }
+        
+        .cyber-restart-button:active {
+            transform: translateY(0) scale(0.98);
+        }
+        
+        @media (max-width: 768px) {
+            .cyber-restart-button {
+                font-size: 6vw;
+                padding: 18px;
+            }
+        }
+        
+        @media (max-height: 600px) {
+            .cyber-restart-button {
+                font-size: 4vw;
+                padding: 15px;
+            }
+        }
+        </style>
+        
+        <button class="cyber-restart-button" id="cyberRestartButton">
+            üîÑ CONTINUAR MATCH
+        </button>`;
+
+    const restartButtonElement = this.add.dom(w / 2, 3 / 4 * h).createFromHTML(restartButtonHtml);
+    restartButtonElement.setOrigin(0.5, 0.5);
+    restartButtonElement.setDepth(100);
+    restartButtonElement.setAlpha(0);
+    restartButtonElement.setScale(0.8);
+
+    // Add click event
+    restartButtonElement.addListener('click');
+    restartButtonElement.on('click', (event) => {
+      if (event.target.id === 'cyberRestartButton') {
+        this.scene.stop();
+        this.onRestart();
+      }
+    });
+
+    // Animate entrance
+    this.add.tween({
+      targets: restartButtonElement,
+      alpha: 1,
+      scale: 1,
+      duration: 600,
+      ease: 'Back.easeOut',
     });
   }
 
   addEndButton (w, h) {
-    const end = this.add.text(w / 2, 3 / 4 * h, 'Terminar', {
-      font: '4vh monospace',
-      fill: '#990000',
-    }).setInteractive();
-
-    end.setOrigin(0.5);
-    end.on('pointerup', async () => {
-      this.scene.stop();
-      await this.onEnd();
-      window.location.reload();
+    // Create cyberpunk end button using DOM element
+    const endButtonHtml = `
+        <style>
+        .cyber-end-button {
+            background: linear-gradient(45deg, #ff3300, #ff6600);
+            border: none;
+            padding: 20px;
+            font-size: 5vw;
+            font-family: 'Orbitron', monospace;
+            font-weight: 900;
+            color: #fff;
+            cursor: pointer;
+            transition: all 0.3s ease;
+            text-transform: uppercase;
+            letter-spacing: 2px;
+            overflow: hidden;
+            border-radius: 8px;
+            box-shadow: 
+                0 0 30px rgba(255, 51, 0, 0.5),
+                0 5px 15px rgba(0, 0, 0, 0.3);
+            width: 90vw;
+            max-width: 500px;
+            position: relative;
+            text-shadow: 0 0 5px #000;
+        }
+        
+        .cyber-end-button::before {
+            content: '';
+            position: absolute;
+            top: 0;
+            left: -100%;
+            width: 100%;
+            height: 100%;
+            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
+            transition: left 0.5s;
+        }
+        
+        .cyber-end-button:hover::before {
+            left: 100%;
+        }
+        
+        .cyber-end-button:hover {
+            transform: translateY(-2px) scale(1.02);
+            box-shadow: 
+                0 0 50px rgba(255, 51, 0, 0.8),
+                0 10px 25px rgba(0, 0, 0, 0.5);
+            background: linear-gradient(45deg, #ff4400, #ff7700);
+        }
+        
+        .cyber-end-button:active {
+            transform: translateY(0) scale(0.98);
+        }
+        
+        @media (max-width: 768px) {
+            .cyber-end-button {
+                font-size: 6vw;
+                padding: 18px;
+            }
+        }
+        
+        @media (max-height: 600px) {
+            .cyber-end-button {
+                font-size: 4vw;
+                padding: 15px;
+            }
+        }
+        </style>
+        
+        <button class="cyber-end-button" id="cyberEndButton">
+            üèÅ TERMINAR PARTIDA
+        </button>`;
+
+    const endButtonElement = this.add.dom(w / 2, 3 / 4 * h).createFromHTML(endButtonHtml);
+    endButtonElement.setOrigin(0.5, 0.5);
+    endButtonElement.setDepth(100);
+    endButtonElement.setAlpha(0);
+    endButtonElement.setScale(0.8);
+
+    // Add click event
+    endButtonElement.addListener('click');
+    endButtonElement.on('click', async (event) => {
+      if (event.target.id === 'cyberEndButton') {
+        this.scene.stop();
+        await this.onEnd();
+        window.location.reload();
+      }
+    });
+
+    // Animate entrance
+    this.add.tween({
+      targets: endButtonElement,
+      alpha: 1,
+      scale: 1,
+      duration: 600,
+      ease: 'Back.easeOut',
     });
   }
 
   addWinner (w, h) {
-    const winnerText = this.make.text({
-      x: w / 2,
-      y: h / 3,
-      text: `${this.i18n.get('winner')}: ${this.game.winner}\n${this.game.winnerSecs} segs.`,
-      style: {
-        font: '4vw monospace',
-        fill: '#000000',
-        align: 'center',
-      },
-    }).setOrigin(0.5, 0.5)
-      .setScale(0);
+    // Create cyberpunk winner text using DOM element
+    const winnerHtml = `
+        <style>
+        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
+        
+        .cyber-winner {
+            font-family: 'Orbitron', 'Courier New', monospace;
+            font-size: 6vw;
+            font-weight: 900;
+            color: #ffff00;
+            text-align: center;
+            text-transform: uppercase;
+            letter-spacing: 3px;
+            line-height: 1.2;
+            text-shadow: 
+                0 0 5px #000,
+                0 0 10px #000,
+                0 0 15px #000,
+                0 0 20px #000,
+                0 0 10px #ffff00,
+                0 0 20px #ffff00,
+                0 0 30px #ffff00,
+                0 0 40px #ffff00;
+            animation: winnerGlow 2s ease-in-out infinite alternate;
+            background: rgba(0, 0, 0, 0.8);
+            padding: 3vh;
+            border-radius: 12px;
+            border: 2px solid #ffff00;
+            box-shadow: 
+                0 0 30px rgba(255, 255, 0, 0.3),
+                inset 0 0 20px rgba(0, 0, 0, 0.7);
+        }
+        
+        @keyframes winnerGlow {
+            0% { 
+                text-shadow: 
+                    0 0 5px #000,
+                    0 0 10px #000,
+                    0 0 15px #000,
+                    0 0 20px #000,
+                    0 0 10px #ffff00,
+                    0 0 20px #ffff00,
+                    0 0 30px #ffff00,
+                    0 0 40px #ffff00;
+                box-shadow: 
+                    0 0 30px rgba(255, 255, 0, 0.3),
+                    inset 0 0 20px rgba(0, 0, 0, 0.7);
+            }
+            100% { 
+                text-shadow: 
+                    0 0 8px #000,
+                    0 0 15px #000,
+                    0 0 20px #000,
+                    0 0 25px #000,
+                    0 0 15px #ffff00,
+                    0 0 25px #ffff00,
+                    0 0 35px #ffff00,
+                    0 0 45px #ffff00,
+                    0 0 55px #ffff00;
+                box-shadow: 
+                    0 0 40px rgba(255, 255, 0, 0.6),
+                    inset 0 0 20px rgba(0, 0, 0, 0.7);
+            }
+        }
+        
+        .winner-name {
+            color: #00f5ff;
+            font-size: 1.2em;
+            margin-top: 1vh;
+        }
+        
+        .winner-time {
+            color: #39ff14;
+            font-size: 0.8em;
+            margin-top: 0.5vh;
+            font-weight: 700;
+        }
+        
+        @media (max-width: 768px) {
+            .cyber-winner { font-size: 8vw; padding: 2vh; }
+        }
+        </style>
+        
+        <div class="cyber-winner">
+            üèÜ GANADOR
+            <div class="winner-name">${this.game.winner.toUpperCase()}</div>
+            <div class="winner-time">‚è±Ô∏è TIEMPO: ${this.game.winnerSecs} s.</div>
+        </div>`;
+
+    const winnerElement = this.add.dom(w / 2, h / 3).createFromHTML(winnerHtml);
+    winnerElement.setOrigin(0.5, 0.5);
+    winnerElement.setDepth(10);
+    winnerElement.setAlpha(0);
+    winnerElement.setScale(0.8);
 
+    // Animate entrance
     this.add.tween({
-      targets: winnerText,
+      targets: winnerElement,
+      alpha: 1,
       scale: 1,
-      duration: 500,
-      ease: 'Sine.easeInOut',
+      duration: 800,
+      ease: 'Back.easeOut',
     });
   }
 
   addSummary (w, h) {
-    const summaryText = this.game.getSummary()
-      .map((s) => `${s.player}: ${s.secs} segs.`)
-      .join('\n');
-
-    const summary = this.make.text({
-      x: w / 2,
-      y: h / 2,
-      text: summaryText,
-      style: {
-        font: '4vw monospace',
-        fill: '#000000',
-        align: 'center',
-      },
-    }).setOrigin(0.5, 0.5)
-      .setScale(0);
+    const summary = this.game.getSummary();
+    const colors = ['#00f5ff', '#ff0080', '#39ff14', '#ffff00', '#ff6600', '#00cccc', '#6600cc', '#cccc00'];
+    
+    // Create cyberpunk results summary using DOM element
+    const summaryHtml = `
+        <style>
+        .cyber-summary {
+            font-family: 'Orbitron', 'Courier New', monospace;
+            text-align: center;
+            max-width: 90vw;
+            margin: 0 auto;
+        }
+        
+        .summary-title {
+            font-size: 4vw;
+            font-weight: 900;
+            color: #00f5ff;
+            text-transform: uppercase;
+            letter-spacing: 2px;
+            margin-bottom: 3vh;
+            text-shadow: 
+                0 0 5px #000,
+                0 0 10px #000,
+                0 0 15px #000,
+                0 0 20px #000,
+                0 0 10px #00f5ff,
+                0 0 20px #00f5ff,
+                0 0 30px #00f5ff;
+        }
+        
+        .player-result {
+            display: flex;
+            justify-content: space-between;
+            align-items: center;
+            padding: 2vh 3vw;
+            margin: 1vh auto;
+            border-radius: 12px;
+            font-size: 3.5vw;
+            font-weight: 700;
+            text-transform: uppercase;
+            letter-spacing: 1px;
+            text-shadow: 
+                0 0 2px #000,
+                0 0 4px #000;
+            border: 2px solid;
+            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
+            max-width: 80vw;
+            transition: all 0.3s ease;
+        }
+        
+        .player-result:hover {
+            transform: translateY(-3px) scale(1.02);
+        }
+        
+        .player-name {
+            flex: 1;
+            text-align: left;
+        }
+        
+        .player-time {
+            flex: 1;
+            text-align: right;
+            font-weight: 900;
+        }
+        
+        .player-result.color-0 {
+            background: linear-gradient(135deg, #00f5ff, #0099cc);
+            border-color: #00f5ff;
+            color: white;
+            box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
+        }
+        
+        .player-result.color-1 {
+            background: linear-gradient(135deg, #ff0080, #cc0066);
+            border-color: #ff0080;
+            color: white;
+            box-shadow: 0 0 30px rgba(255, 0, 128, 0.3);
+        }
+        
+        .player-result.color-2 {
+            background: linear-gradient(135deg, #39ff14, #2ecc40);
+            border-color: #39ff14;
+            color: white;
+            box-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
+        }
+        
+        .player-result.color-3 {
+            background: linear-gradient(135deg, #ffff00, #cccc00);
+            border-color: #ffff00;
+            color: black;
+            box-shadow: 0 0 30px rgba(255, 255, 0, 0.3);
+        }
+        
+        .player-result.color-4 {
+            background: linear-gradient(135deg, #ff6600, #cc5500);
+            border-color: #ff6600;
+            color: white;
+            box-shadow: 0 0 30px rgba(255, 102, 0, 0.3);
+        }
+        
+        .player-result.color-5 {
+            background: linear-gradient(135deg, #00cccc, #00aaaa);
+            border-color: #00cccc;
+            color: white;
+            box-shadow: 0 0 30px rgba(0, 204, 204, 0.3);
+        }
+        
+        .player-result.color-6 {
+            background: linear-gradient(135deg, #6600cc, #5500aa);
+            border-color: #6600cc;
+            color: white;
+            box-shadow: 0 0 30px rgba(102, 0, 204, 0.3);
+        }
+        
+        .player-result.color-7 {
+            background: linear-gradient(135deg, #cccc00, #aaaa00);
+            border-color: #cccc00;
+            color: black;
+            box-shadow: 0 0 30px rgba(204, 204, 0, 0.3);
+        }
+        
+        @media (max-width: 768px) {
+            .summary-title { font-size: 5vw; }
+            .player-result { font-size: 4.5vw; padding: 1.5vh 2vw; }
+        }
+        </style>
+        
+        <div class="cyber-summary">
+            <div class="summary-title">üìä RANKING</div>
+            ${summary.map((s, index) => `
+                <div class="player-result color-${index % 8}">
+                    <div class="player-name">${s.player.toUpperCase()}</div>
+                    <div class="player-time">${s.secs}s</div>
+                </div>
+            `).join('')}
+        </div>`;
+
+    const summaryElement = this.add.dom(w / 2, h / 2 + 50).createFromHTML(summaryHtml);
+    summaryElement.setOrigin(0.5, 0.5);
+    summaryElement.setDepth(10);
+    summaryElement.setAlpha(0);
+    summaryElement.setScale(0.9);
 
+    // Animate entrance with staggered effect for each player
     this.add.tween({
-      targets: summary,
+      targets: summaryElement,
+      alpha: 1,
       scale: 1,
-      duration: 500,
-      ease: 'Sine.easeInOut',
+      duration: 600,
+      ease: 'Back.easeOut',
+    });
+
+    // Add individual card animations with delay
+    const playerCards = summaryElement.node.querySelectorAll('.player-result');
+    playerCards.forEach((card, index) => {
+      const delay = 100 * index;
+      setTimeout(() => {
+        card.style.animation = 'slideInUp 0.5s ease-out forwards';
+      }, delay);
     });
+
+    // Add CSS animation for individual cards
+    const style = document.createElement('style');
+    style.textContent = `
+      @keyframes slideInUp {
+        from {
+          opacity: 0;
+          transform: translateY(30px);
+        }
+        to {
+          opacity: 1;
+          transform: translateY(0);
+        }
+      }
+    `;
+    document.head.appendChild(style);
   }
 }
 

```

---

```bash
git commit -m "feat: la pantalla de finalizaci√≥n adopta el dise√±o neon/cyber coherente con el resto del juego"
```

```
[main 21b29eb] feat: la pantalla de finalizaci√≥n adopta el dise√±o neon/cyber coherente con el resto del juego
 3 files changed, 902 insertions(+), 57 deletions(-)
 create mode 100644 ".specstory/history/2025-09-24_12-37Z-adaptar-pantalla-para-coherencia-de-dise\303\261o.md"
 create mode 100644 docs/features/0007_PLAN.md

```

---

```bash
git push
```

```
To github.com:heedrox/triangulame.git
   15697a4..21b29eb  main -> main

```

---

¬°Perfecto! He completado exitosamente la implementaci√≥n del redise√±o neon/cyber de la pantalla de finalizaci√≥n y realizado el commit con push.

## Resumen de lo implementado:

‚úÖ **Fondo cyberpunk completo**: Grid animado, gradientes, tri√°ngulos neon y part√≠culas flotantes
‚úÖ **Texto del ganador estilizado**: DOM element con tipograf√≠a Orbitron, efectos glow y animaciones
‚úÖ **Resumen de resultados**: Lista de tarjetas con colores neon y animaciones escalonadas  
‚úÖ **Botones cyberpunk**: "CONTINUAR MATCH" y "TERMINAR PARTIDA" con efectos hover y transiciones
‚úÖ **Animaciones mejoradas**: Entrada escalonada de elementos con efectos Back.easeOut

La pantalla de finalizaci√≥n ahora mantiene **coherencia visual completa** con las escenas de bienvenida y jugadores, usando la misma paleta de colores (cian, magenta, verde, amarillo), tipograf√≠a Orbitron, y efectos neon. 

El commit se ha realizado con el mensaje: `feat: la pantalla de finalizaci√≥n adopta el dise√±o neon/cyber coherente con el resto del juego` y se ha subido al repositorio.

---

