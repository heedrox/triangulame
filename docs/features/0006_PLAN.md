## 0006 – Rediseño neon/cyber de la pantalla de partida (PlayingScene)

### Descripción breve
Actualizar la UI in‑game de `src/phaser-ui/scenes/playing-scene.js` para que adopte una estética neon/cyber inspirada en `redesign/neon-cyber-design.html`: fondos con grid animado, tipografía “tech”, colores vibrantes con efecto glow, partículas flotantes, HUD inferior estilizado y feedback de combo más impactante. Mantener la lógica de juego intacta (detección de clicks, progreso, combos, temporizador) y limitar cambios a la capa visual.

### Archivos a modificar/crear
- `src/phaser-ui/scenes/playing-scene.js`
  - Añadir capas visuales (grid animado, partículas, vignette), nuevos estilos de textos, colores y “glow” simulado en bordes.
  - Ajustar `paintBottom`, `paintGoal`, `paintProgress*`, `addRectangle`, `addTextToRectangle`, `removeRectangle`, `showCombo` para el estilo neon.
- `index.html`
  - Incluir fuente `Orbitron` desde Google Fonts para títulos/textos tipo “tech” usados por Phaser Text.
- (Opcional) `src/phaser-ui/scenes/constants/` (nuevo archivo `theme-colors.js`)
  - Centralizar paleta neon (cian, magenta, verde lima, amarillo) y opacidades de glow.
- (Opcional) `src/assets/particles/` (texturas pequeñas de partícula, si se prefiere a partículas geométricas por defecto).

### Cambios propuestos en `PlayingScene`
1) Capas de fondo (create)
   - `this.addCyberBackground()`
     - Crear un `tileSprite` a pantalla completa para un “grid” neon (líneas finas cian) que se desplaza lentamente (scroll X/Y en `update` o tween). Emula `.cyber-grid` de `neon-cyber-design.html`.
     - Añadir una capa de fondo base con `Graphics` usando un gradiente aproximado por rectángulos semitransparentes superpuestos para simular el `radial-gradient`+`linear-gradient` de la demo. Mantenerlo sutil para no interferir con el tablero.
   - `this.addVignette()`
     - Dibujar bordes oscuros semi‑transparentes (cuatro rectángulos o un polígono) para dar profundidad tipo “pantalla”.

2) Partículas flotantes (create)
   - `this.addFloatingParticles()`
     - Crear un `ParticleEmitterManager` con partículas muy pequeñas (2‑4px), colores alternos (cian, magenta, verde, amarillo), baja opacidad, movimiento vertical con leve variación horizontal, vida 5‑8s, emisión constante pero ligera (~5‑10/s). Emula la sección `.particles` del HTML.

3) Estilizado de tablero (líneas y números)
   - `buildGraphics()`
     - Cambiar el `lineStyle` a blanco puro (núcleo) y, antes de trazar el borde blanco, trazar un borde más grueso y semi‑transparente con color acento (cian o color del jugador activo) para simular glow (doble pasada: primero “aura” con alfa 0.25‑0.4, luego línea blanca fina).
   - `addRectangle(rectangle)`
     - Usar la doble pasada comentada para cada polígono.
   - `addTextToRectangle(rectangle)`
     - Cambiar estilo de `Text` a tipografía Orbitron (si cargada por CSS), color blanco, `stroke` de 8‑12px con color acento suave y `setShadow` para neón (por ejemplo sombra blanca suave + sombra de color). Mantener escala con `getStretch`.

4) HUD inferior (barra y progreso)
   - `paintBottom()`
     - Reemplazar fondo negro sólido por una franja oscura translúcida con borde exterior “cyber” (rectángulo ancho, luego un rectángulo interno negro para “bisel”). Añadir una sutil línea acento superior/inferior (cian) con baja opacidad para separar.
   - `paintGoal()`
     - El recuadro del objetivo actual pasa a ser un rectángulo con color del jugador activo, opacidad 0.8, borde cian/magenta tenue y glow simulado (rect exterior más grande con alfa 0.2). El texto objetivo usa Orbitron, blanco con `stroke` acento y `setShadow` (glow), conserva la animación bounce existente.
   - `paintProgressForPlayer()`
     - Fondo de cada barra: rectángulo negro translúcido. Progreso: color del jugador con doble pasada (una barra glow translúcida más grande detrás + barra sólida delante). Mantener la lógica de cálculo `currentProgress`.

5) Feedback visual al acertar (removeRectangle / combo)
   - `removeRectangle()`
     - Además del “spin & scale”, añadir un destello: crear un `Graphics`/`Image` temporal sobre el polígono con color BACKGROUND_PIECE cercano a amarillo, escalar a 1.2 y desvanecer rápidamente (<=250ms). Puede añadirse un `particle burst` local con pocas partículas para enfatizar.
   - `showCombo(number)`
     - Cambiar a tipografía Orbitron, multi‑línea “COMBO xN” con fuerte `stroke` y `shadow` de color acento (magenta). Aumentar escala y fade con easing suave; añadir pequeño “screen shake” opcional (`this.cameras.main.shake(120, 0.002)`).

6) Colores y tema
   - Introducir una paleta inspirada en el HTML:
     - Cian: #00f5ff, Magenta: #ff0080, Lima: #39ff14, Amarillo: #ffff00.
   - Asignación de color determinista por figura sin dar pistas por id/tipo:
     - offset = djb2(String(totalRects)) % 4
     - colorIndex = (id + offset) % 4
     - palette[colorIndex] con palette = [cian, magenta, lima, amarillo]
     - Mejora opcional: si dos consecutivos resultan con mismo color al pintar, usar (colorIndex + 1) % 4 para el segundo.
   - Mapear `PLAYERS_COLORS` a estos tonos, o usarlos como acentos globales.
   - BACKGROUND_PIECE puede ajustarse a un amarillo más vivo (#cccc00 → #ffff00 con alfa de relleno).

   Nota: no se usa `roomId` en `PlayingScene`. El hash sobre `totalRects` garantiza una semilla común determinista para todos los clientes y cambia entre partidas, evitando que el color sea pista del número.

7) Tipografía
   - Añadir en `index.html`:
     - `<link rel="preconnect" href="https://fonts.googleapis.com">` y carga de `Orbitron:wght@400;700;900`.
   - En Phaser, usar `fontFamily: 'Orbitron, monospace'` en textos (no requiere WebFontLoader si ya está en el DOM antes de crear la escena).

### Algoritmo/flujo visual (paso a paso)
1) preload
   - Mantener carga de audio. (No se cargan assets extra salvo textura de partícula opcional.)
2) create
   - `addCyberBackground()` → grid (tileSprite) + fondo gradiente aproximado + vignette.
   - `addFloatingParticles()` → emisor de partículas de fondo.
   - `buildGraphics()` → configurar estilos neon (doble pasada) y pintar rectángulos con `paintScreen()`.
   - Suscribir input y música como hasta ahora.
3) interacción
   - `checkRectanglePressed()` → sin cambios lógicos; en acierto: `removeRectangle()` mejorado + `checkCombo()`.
4) HUD
   - `paintBottom()` → franja estilizada.
   - `paintGoal()` y `paintProgress()` → estilos neon con doble pasada y sombras.
5) combo
   - `showCombo()` → texto Orbitron con glow + opcional shake.
6) update (si se añade)
   - Mover lentamente el `tileSprite` del grid (p. ej., `this.grid.tilePositionX += 0.1; this.grid.tilePositionY += 0.05`).

### Consideraciones de rendimiento
- Mantener número de partículas bajo (<= 200 activas) y opacidades bajas.
- Evitar pipelines personalizados; simular glow con dobles pasadas de `Graphics` y `stroke/shadow` en `Text`.
- Reutilizar `Graphics` donde sea posible; minimizar creaciones por frame.

### Fases (iterables)
- Fase 1: Base visual
  - Fuente Orbitron en `index.html`, grid animado, ajustes de `buildGraphics`, textos con stroke/shadow, HUD inferior estilizado.
- Fase 2: Feedback y partículas
  - Partículas de fondo, destellos en `removeRectangle`, combo reforzado con shake.
- Fase 3: Pulido y tema
  - Paleta centralizada, ajuste de BACKGROUND_PIECE, balance de opacidades/contraste y pruebas en distintos tamaños/aspect ratios.

### Impacto en API/lógica
- Ninguno. Todo cambio es visual y local a `PlayingScene`. No se modifican contratos con `eventsCenter`, `ComboCheck` ni dominio.


