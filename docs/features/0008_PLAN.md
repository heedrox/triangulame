## 0008 – Mejorar tasa de refresco en móvil (welcome-scene y ending-scene)

Breve descripción
- Optimizar rendimiento y frame rate en móviles en las escenas `src/phaser-ui/scenes/welcome-scene.js` y `src/phaser-ui/scenes/ending-scene.js` reduciendo draw calls, uso de DOM/CSS costoso, cantidad de tweens y objetos gráficos, y ajustando la configuración del renderer de Phaser.

Archivos y funciones implicadas
- `src/phaser-ui/scenes/welcome-scene.js`
  - `createCyberBackground`, `createGradientBackground`, `createRadialGlows`, `drawTriangleGlow`, `createAnimatedGrid`, `createFloatingParticles`, `animateParticle`, `addForm`, `addStartButton`, `addFullScreenButton`.
- `src/phaser-ui/scenes/ending-scene.js`
  - Misma familia de métodos: fondo, glows, grid, partículas, UI DOM (restart/end, winner, summary).
- `src/phaser-ui/index.js` (o donde se cree el `Phaser.Game`)
  - Ajustes del renderer (WebGL, DPR, antialias, powerPreference, roundPixels, transparent, dom).
- Nuevos utilitarios propuestos
  - `src/phaser-ui/scenes/utils/perf-textures.js`: helpers para prerender/caché (gradiente, grid) a texturas.
  - `src/phaser-ui/scenes/utils/adaptive-quality.js`: detección de dispositivo/rendimiento y escalados de calidad.
  - `src/phaser-ui/scenes/utils/dom-styles.js`: inyección de estilos globales única, variantes mobile, y helpers para clases.

Plan técnico de cambios
1) Configuración global de Phaser (renderer)
   - Forzar WebGL si disponible y preferencia de alto rendimiento: `type: Phaser.WEBGL`, `render: { powerPreference: 'high-performance' }`.
   - Desactivar antialias y transparencia si no son críticos: `antialias: false`, `transparent: false`.
   - Redondeo de píxeles: `roundPixels: true` para reducir subpíxel en sprites/text.
   - Limitar resolución efectiva en móvil: `resolution = Math.min(window.devicePixelRatio, 2)` o menor (1.5) bajo modo low-perf.
   - Activar `dom: { createContainer: true }` solo si se usan elementos DOM; evitar múltiples contenedores.

2) Prerender y caché de fondos en ambas escenas
   - Sustituir `createGradientBackground` para que dibuje el gradiente una sola vez en un `Graphics`, lo vuelque a `RenderTexture`/`Texture` con clave (`bg-gradient-{w}x{h}`) y reutilice el `Image` resultante.
   - Reemplazar los glows triangulares múltiples (`drawTriangleGlow` crea 6 capas x 3 glows = 18 Graphics) por:
     - Opción A: generar una sola textura de triángulo glow (varios tamaños) y colocar 3 `Image` con `blendMode: ADD`.
     - Opción B: reducir capas a 2-3 en móvil (controlado por adaptive quality) y volcar a textura.
   - Grid animado: dibujar una rejilla en un `Graphics` una sola vez, crear textura y usar `TileSprite` para desplazar UVs en lugar de mover un `Graphics` con miles de líneas activas.

3) Partículas: pooling y menos tweens
   - Reducir el número en móvil (ej.: 12 → 4-6). Definir por calidad: alta/med/baja.
   - Pool de partículas: crear N `Graphics`/`Image` reutilizables. Evitar crear/destruir objetos en cada ciclo.
   - Sustituir varios tweens simultáneos por un único tween compuesto o una actualización manual en `scene.events.on('update', ...)` que mueva `y`, `alpha` y `rotation` con interpolación ligera.
   - Usar `setAlpha`/`setRotation` directos y evitar `onComplete` recursivos; reutilizar del pool con temporizadores escalonados.

4) UI basada en DOM: minimizar coste de layout/paint
   - Evitar inyectar `<style>` por escena repetidamente. Mover estilos comunes a una sola inyección global (módulo `dom-styles.js`) con id de estilo para no duplicar.
   - Crear variantes mobile que reduzcan `text-shadow` y `box-shadow` múltiples (p.ej. pasar de 8 capas a 1 capa o ninguna), y desactivar animaciones CSS costosas (pulsos, brillos) en móvil.
   - Añadir `will-change: transform` solo en elementos que realmente animen. Quitar `animation` en botones estáticos en mobile.
   - Reutilizar el mismo contenedor DOM si la escena se reinicia; destruir explícitamente en `shutdown/destroy` para evitar fugas.
   - Alternativa futura: migrar a UI con Phaser (Text/BitmapText + Graphics) para unificar pipeline y evitar reflow.

5) Tweens y animaciones
   - Consolidar tweens: botones y grid deben tener un único tween o animación por elemento.
   - Sustituir animación del grid por desplazamiento de `tilePosition` en `TileSprite` dentro de `update` o un tween único.
   - Limitar duraciones infinitas con `repeat: -1` cuando no sea imprescindible; usar velocidad baja en `update` (menos overhead que múltiples tweens).

6) Ciclo de vida y limpieza
   - Añadir listeners `this.events.on('shutdown')`/`this.events.on('destroy')` en ambas escenas para:
     - `destroy()` de DOM Elements (`this.add.dom(...)`), `Graphics`, `TileSprite`, `RenderTextures` no compartidas, y `tweens` activos.
   - Asegurar que `this.particles` y referencias a pools se vacíen al salir de la escena.

7) Calidad adaptativa (adaptive quality)
   - Heurística inicial: si `this.game.device.os.desktop === false` marcar mobile y usar perfil de calidad medio.
   - Medición runtime: muestrear `game.loop.actualFps`/`game.loop.delta` durante 2-3 segundos; si FPS < 45 de forma sostenida, bajar calidad (menos partículas, sin glows múltiples, grid sin animación). Si > 55, se permite calidad media.
   - Flags externas: `?perf=low|med|high` para forzar perfil y `localStorage.triangulamePerf` como override.

8) Medición y diagnóstico
   - Opción debug: overlay de FPS y contadores de objetos (`this.children.length`, partículas activas, tweens activos) con tecla oculta o flag de query.
   - Log de una sola línea al entrar a escena con el perfil elegido y DPR efectivo.

Detalles de implementación por archivo
- `welcome-scene.js`
  - Reemplazar `createGradientBackground` por generación y uso de textura cacheada.
  - `createRadialGlows` → usar texturas glow pre-generadas o reducir capas por perfil.
  - `createAnimatedGrid` → crear `TileSprite` a partir de textura de rejilla; animar con desplazamiento de `tilePosition` en `update`.
  - `createFloatingParticles`/`animateParticle` → implementar pool y reducción de tweens, menor cantidad en móvil.
  - `addForm`/`addStartButton` → mover estilos a `dom-styles.js`, aplicar clases `is-mobile` para sombras/animaciones reducidas.

- `ending-scene.js`
  - Misma estrategia de fondo/glows/grid/partículas.
  - Reducir animaciones CSS en `addWinner`/`addSummary` (menos text-shadows y sin animación continua en mobile). Inyectar estilos a través de `dom-styles.js` y condicionar por perfil.

- `phaser-ui/index.js` (o archivo de bootstrap del juego)
  - Ajustar `new Phaser.Game(config)` con renderer y resolución cap.
  - Exponer `qualityProfile` y `effectiveResolution` en `game.registry` o un singleton accesible desde escenas.

- Nuevos módulos
  - `perf-textures.js`: funciones `getOrCreateGradientTexture(scene, w, h)`, `getOrCreateGridTexture(scene, w, h, gridSize)`, `getOrCreateTriangleGlowTexture(scene, size, color)` con almacenamiento en `scene.textures`.
  - `adaptive-quality.js`: `detectInitialProfile(game)`, `measureAndAdjust(scene)`, `getProfile()`.
  - `dom-styles.js`: `ensureGlobalStylesInjected(profile)`, `applyMobileClasses(rootEl)`; estilos con menos sombras/animaciones en mobile.

Algoritmos (resumen)
- Limitación de DPR: `effectiveDpr = mobile ? Math.min(window.devicePixelRatio, 1.5) : Math.min(window.devicePixelRatio, 2)`.
- Adaptive quality:
  1. Seleccionar perfil por dispositivo o query param.
  2. Durante los primeros ~2000 ms, muestrear FPS medio.
  3. Si `fps < 45`, degradar un nivel; si `fps > 55` y no en high, subir a medio.
  4. Aplicar cambios: (partículas N, capas de glow, animación de grid on/off, sombras CSS on/off).
- Grid como TileSprite:
  - Generar textura 2D del patrón (vertical/horizontal cada `gridSize`).
  - Crear `tileSprite` a pantalla completa y actualizar `tilePositionX/Y` lentamente en `update`.

Notas de compatibilidad
- Mantener una ruta “desktop/high” que preserve el look actual y una ruta “mobile/med-low” que reduzca sutilmente efectos sin cambiar UX funcional.
- Evitar dependencias nuevas; todo con Phaser 3 y utilitarios propios.

### Top 3 acciones de mayor impacto (prioridad)
- 1) Ajustes de renderer y DPR cap (global): forzar WebGL alto rendimiento, `antialias: false`, `roundPixels: true`, `resolution = min(devicePixelRatio, 1.5 en móvil)`. Impacto directo en fill-rate y overdraw.
- 2) Grid como `TileSprite` con textura cacheada: sustituir `Graphics` + tweens infinitos por `TileSprite` desplazando `tilePosition`. Reduce draw calls y coste de CPU/GPU en ambas escenas.
- 3) Partículas con pool y menos tweens: bajar cantidad en móvil y animar vía `update` o un tween por partícula ciclo, evitando recursión y múltiples tweens simultáneos.

Empezaremos por estas tres tareas para obtener la mayor mejora de FPS con el menor cambio de código.


